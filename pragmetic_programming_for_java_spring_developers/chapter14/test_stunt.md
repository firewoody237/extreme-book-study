### 테스트 대역
- 테스트를 위해 실제 객체를 대신하는 객체
- 테스트 대역을 통해 격리되고 고정된 테스트 환경을 만들 수 있음

## 14.1 Dummy
- 아무런 동작도 하지 않음
- `NPE`나 `Filter Chain`처럼 테스트에 있어서 동작하지 않아도 되지만, 객체 자체가 필요할 때 사용

## 14.2 Stub
- 원본의 응답을 복제해 준비된 동일한 값을 반환하는 대역 객체
- 특정 Edge Case를 테스트 해 볼 수 있음
- 고연산 작업인 API, I/O, 네트워크 호출 등의 작업을 대신할 수 있음
```java
class StubEmptyUserRepository implements UserRepository {
    public Optional<User> findByEmail(String email) {
        return Optional.empty();
    }
}
```

- `Mockito`를 사용하여 만들 수 있지만, 기본적으로 `Mockito`는 대역을 쉽게 만들어 줄 뿐 객체의 생성이 `Mockito`와 의존적이지는 않음
- `Mockito`를 통해 아래와 같이 만들 수 있음
```java
given(userRepository.findByEmail("foobar@localhost.com"))
    .willReturn(...);
```

- 객체를 대신하기보다 메서드의 동작을 바꾸는 것으로 여겨질 때가 많아 "메서드 스텁"이라는 용어로 불리기도 함

## 14.3 Fake
- 자체적인 논리를 가지고 있는 대역
- Stub은 고정적인 반환을 주는 대역이기 때문에, Stub을 조건별로 만들다보면 테스트용 코드가 많아짐
  - 따라서 매번 Stub을 달리 하는 것은 테스크 코드의 가독성을 저하
- 잘 만들어두면 여러 테스트에서 재활용할 수 있음
- 간단한 메모리 변수를 통해 아래와 같이 Repository를 대체할 수 있음

```java
class FakeEmptyUserRepository implements UserRepository {

    private final long autoGeneratedId = 0;
    private final List<User> data = new ArrayList<>();

    public Optional<User> findByEmail(String email) {
        return data.stream()
            .filter(item -> item.getId().equals(id))
            .findAny();
    }
}
```

> Fake 객체를 통해 "빠른 테스트"를 만들 수 있음 (중형 테스트 -> 소형 테스트의 전환)

## 14.4 Mock
- 메서드 호출 및 상호 작용을 기록
- 어떤 객체와 상호 작용이 일어났는지 기록
- 어떻게 상호 작용이 일어났는지 기록

### 상태 기반 검증
- 테스트를 실행한 후 테스트 대상의 상태가 어떻게 변화되었지로 테스트 결과를 판단

### 행위 기반 검증
- 테스트 대상이나 협력 객체, 협력 시스템의 메서드 호출 여부를 봄
- 좋은 테스트 방식이 아님
  - 테스트가 논리를 검증하고 있으므로 테스트 대상이 현재 코드 외에 다른 방법으로 개발하는 것이 불가능

```java
public class MockVerificationEmailSender implements VerificationEmailSender {
    public boolean isSendCalled = false;

    @Override
    public void send(User user) {
        this.isSendCalled = true;
    }
}
```

## 14.5 Spy
- 객체 입장에서, 어떤 메서드가 호출되고 이벤트가 발생했는지 기록하고 감시하는 대역
- 실제 객체와 구분할 수 없음 (`Mock`의 경우 기본적으로 메서드 호출은 `Dummy` 혹은 `Stub` 처럼 동작)

### 구현 방법
- 상속을 이용하는 방법

```java
public class SpyUserRepository extends UserRepositoryImpl {

    public int findByEmailCallCount = 0;
    public int saveCallCount = 0;

    // ...
}
```

- 프록시 패턴을 이용하는 방법

```java
@Repository
@RequiredArgsConstructor
public class SpyUserRepository implements UserRepository {

    public int findByEmailCallCount = 0;
    public int saveCallCount = 0;
    private final UserRepositoryImpl userRepositoryImpl;

    // ...
}
```

- Mockito를 이용하는 방법

```java
verify(...)
given(...)
```

## 14.6 정리
- `Mockito`는 기술이므로, "대역"자체의 의미를 이해하는 것이 중요

## 추가 - Mockito로 각 대역을 구현하는 코드
### Dummy

```java
public class MyServiceTest {

    public interface SomeDependency {
        String doSomething();
    }

    public static class MyService {
        private final SomeDependency dependency;

        public MyService(SomeDependency dependency) {
            this.dependency = dependency;
        }

        public String process() {
            return "Processed with dependency: " + dependency.doSomething();
        }
    }

    @Test
    void testProcessWithDummyDependency() {
        // 1. Dummy 객체 생성
        SomeDependency dummyDependency = Mockito.mock(SomeDependency.class);

        // 2. 테스트 대상 객체 생성 (Dummy 객체 주입)
        MyService service = new MyService(dummyDependency);

        // 3. 테스트 실행 및 검증
        String result = service.process();
        assertEquals("Processed with dependency: null", result);
    }
}
```

### Stub

```java
public class OrderServiceTest {

    public interface ProductService {
        int getPrice(String productId);
    }

    public static class OrderService {
        private final ProductService productService;

        public OrderService(ProductService productService) {
            this.productService = productService;
        }

        public int calculateOrderAmount(String[] productIds) {
            int totalAmount = 0;
            for (String productId : productIds) {
                totalAmount += productService.getPrice(productId);
            }
            return totalAmount;
        }
    }

    @Test
    void testCalculateOrderAmountWithStub() {
        // 1. Stub 객체 생성
        ProductService productServiceStub = Mockito.mock(ProductService.class);

        // 2. Stub의 특정 메서드 호출에 대한 반환 값 정의 (Stubbing)
        when(productServiceStub.getPrice("productA")).thenReturn(1000);
        when(productServiceStub.getPrice("productB")).thenReturn(2000);

        // 3. 테스트 대상 객체 생성 (Stub 객체 주입)
        OrderService orderService = new OrderService(productServiceStub);

        // 4. 테스트 실행
        String[] productIds = {"productA", "productB"};
        int totalAmount = orderService.calculateOrderAmount(productIds);

        // 5. 결과 검증
        assertEquals(3000, totalAmount);
    }

    @Test
    void testCalculateOrderAmountWithUnknownProduct() {
        // 1. Stub 객체 생성
        ProductService productServiceStub = Mockito.mock(ProductService.class);

        // 2. Stub의 특정 메서드 호출에 대한 반환 값 정의
        when(productServiceStub.getPrice("existingProduct")).thenReturn(1500);
        // 정의되지 않은 productId에 대한 호출은 기본 값(int의 경우 0)을 반환합니다.

        // 3. 테스트 대상 객체 생성
        OrderService orderService = new OrderService(productServiceStub);

        // 4. 테스트 실행
        String[] productIds = {"existingProduct", "unknownProduct"};
        int totalAmount = orderService.calculateOrderAmount(productIds);

        // 5. 결과 검증
        assertEquals(1500, totalAmount); // "unknownProduct"의 가격은 정의되지 않았으므로 0으로 처리됩니다.
        // 정의되지 않으면 기본 반환값을 제공
    }
}
```

### Fake

```java
public class UserServiceTest {

    public interface UserRepository {
        User findById(String userId);
        void save(User user);
        List<User> findAll();
    }

    public static class User {
        private String id;
        private String username;
        private String email;

        public User(String id, String username, String email) {
            this.id = id;
            this.username = username;
            this.email = email;
        }

        public String getId() {
            return id;
        }

        public String getUsername() {
            return username;
        }

        public String getEmail() {
            return email;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            User user = (User) o;
            return id.equals(user.id);
        }

        @Override
        public int hashCode() {
            return id.hashCode();
        }
    }

    public static class UserService {
        private final UserRepository userRepository;

        public UserService(UserRepository userRepository) {
            this.userRepository = userRepository;
        }

        public User getUserById(String userId) {
            return userRepository.findById(userId);
        }

        public void createUser(String id, String username, String email) {
            User newUser = new User(id, username, email);
            userRepository.save(newUser);
        }

        public List<String> getAllUsernames() {
            List<User> users = userRepository.findAll();
            List<String> usernames = new ArrayList<>();
            for (User user : users) {
                usernames.add(user.getUsername());
            }
            return usernames;
        }
    }

    @Test
    void testGetUserByIdWithFakeRepository() {
        // 1. Fake Repository 구현 (Mockito Mock 활용)
        UserRepository fakeRepository = mock(UserRepository.class);
        User expectedUser = new User("123", "testuser", "test@example.com");
        when(fakeRepository.findById("123")).thenReturn(expectedUser);

        // 2. 테스트 대상 서비스 객체 생성 (Fake Repository 주입)
        UserService userService = new UserService(fakeRepository);

        // 3. 테스트 실행
        User actualUser = userService.getUserById("123");

        // 4. 결과 검증
        assertEquals(expectedUser, actualUser);
    }

    @Test
    void testCreateUserWithFakeRepository() {
        // 1. Fake Repository 구현 (Mockito Mock 활용)
        UserRepository fakeRepository = mock(UserRepository.class);

        // 2. 테스트 대상 서비스 객체 생성
        UserService userService = new UserService(fakeRepository);

        // 3. 테스트 실행
        userService.createUser("456", "newuser", "new@example.com");

        // 4. Fake Repository의 save() 메서드가 특정 User 객체로 호출되었는지 검증 (행위 검증)
        Mockito.verify(fakeRepository).save(new User("456", "newuser", "new@example.com"));
    }

    @Test
    void testGetAllUsernamesWithFakeRepository() {
        // 1. Fake Repository 구현
        UserRepository fakeRepository = mock(UserRepository.class);
        List<User> users = List.of(
                new User("1", "user1", "user1@example.com"),
                new User("2", "user2", "user2@example.com"),
                new User("3", "user3", "user3@example.com")
        );
        when(fakeRepository.findAll()).thenReturn(users);

        // 2. 테스트 대상 서비스 객체 생성
        UserService userService = new UserService(fakeRepository);

        // 3. 테스트 실행
        List<String> actualUsernames = userService.getAllUsernames();

        // 4. 결과 검증
        List<String> expectedUsernames = List.of("user1", "user2", "user3");
        assertEquals(expectedUsernames, actualUsernames);
    }
}
```

### Mock

```java
public class EmailServiceTest {

    public interface EmailSender {
        void sendEmail(String to, String subject, String body);
    }

    public static class UserService {
        private final EmailSender emailSender;
        private final List<String> userEmails = List.of("user1@example.com", "user2@example.com");

        public UserService(EmailSender emailSender) {
            this.emailSender = emailSender;
        }

        public void sendWelcomeEmails() {
            for (String email : userEmails) {
                emailSender.sendEmail(email, "Welcome!", "Welcome to our service!");
            }
        }

        public void sendPromotionEmail(String userId, String promotionMessage) {
            // 실제로는 userId를 기반으로 이메일을 가져오는 로직이 있을 수 있지만, 여기서는 단순화를 위해 하드코딩
            if (userId.equals("user1")) {
                emailSender.sendEmail("user1@example.com", "Special Promotion", promotionMessage);
            }
        }
    }

    @Test
    void testSendWelcomeEmailsWithMock() {
        // 1. Mock 객체 생성
        EmailSender mockEmailSender = mock(EmailSender.class);

        // 2. 테스트 대상 객체 생성 (Mock 객체 주입)
        UserService userService = new UserService(mockEmailSender);

        // 3. 테스트 실행
        userService.sendWelcomeEmails();

        // 4. Mock 객체의 특정 메서드가 예상대로 호출되었는지 검증 (행위 검증)
        verify(mockEmailSender, times(1)).sendEmail("user1@example.com", "Welcome!", "Welcome to our service!");
        verify(mockEmailSender, times(1)).sendEmail("user2@example.com", "Welcome!", "Welcome to our service!");
        verifyNoMoreInteractions(mockEmailSender); // 더 이상 상호작용이 없었는지 확인
    }

    @Test
    void testSendPromotionEmailWithMock() {
        // 1. Mock 객체 생성
        EmailSender mockEmailSender = mock(EmailSender.class);

        // 2. 테스트 대상 객체 생성
        UserService userService = new UserService(mockEmailSender);

        // 3. 테스트 실행
        userService.sendPromotionEmail("user1", "Check out our new features!");

        // 4. 특정 인자로 메서드가 호출되었는지 검증
        verify(mockEmailSender).sendEmail("user1@example.com", "Special Promotion", "Check out our new features!");
        verifyNoMoreInteractions(mockEmailSender);
    }

    @Test
    void testSendPromotionEmailForOtherUserWithNoEmailSent() {
        // 1. Mock 객체 생성
        EmailSender mockEmailSender = mock(EmailSender.class);

        // 2. 테스트 대상 객체 생성
        UserService userService = new UserService(mockEmailSender);

        // 3. 테스트 실행 (userId가 "user1"이 아닌 경우)
        userService.sendPromotionEmail("user3", "This should not be sent in this simplified test.");

        // 4. 특정 메서드가 전혀 호출되지 않았는지 검증
        verifyNoInteractions(mockEmailSender);
    }
}
```

### Spy

```java
public class ArticleServiceTest {

    public static class Article {
        private String title;
        private boolean published = false;

        public Article(String title) {
            this.title = title;
        }

        public String getTitle() {
            return title;
        }

        public boolean isPublished() {
            return published;
        }

        public void publish() {
            this.published = true;
            System.out.println("Article '" + title + "' has been published.");
        }

        public String generateSummary(int maxLength) {
            if (title.length() <= maxLength) {
                return title;
            } else {
                return title.substring(0, maxLength) + "...";
            }
        }
    }

    public static class ArticleService {
        public void processArticle(Article article) {
            article.publish();
        }

        public List<String> summarizeArticles(List<Article> articles, int maxLength) {
            List<String> summaries = new ArrayList<>();
            for (Article article : articles) {
                summaries.add(article.generateSummary(maxLength));
            }
            return summaries;
        }
    }

    @Test
    void testProcessArticleWithSpy() {
        // 1. Spy 객체 생성 (실제 Article 객체 기반)
        Article articleToSpy = new Article("Mockito Spy Example");
        Article spyArticle = spy(articleToSpy);

        // 2. 테스트 대상 서비스 객체 생성
        ArticleService articleService = new ArticleService();

        // 3. 테스트 실행
        articleService.processArticle(spyArticle);

        // 4. Spy 객체의 특정 메서드가 호출되었는지 검증
        verify(spyArticle).publish();

        // 5. Spy 객체의 상태가 변경되었는지 검증 (실제 객체 기반이므로 상태 변화가 반영됨)
        assertEquals(true, spyArticle.isPublished());
    }

    @Test
    void testGenerateSummaryWithSpyAndStubbing() {
        // 1. Spy 객체 생성 (실제 Article 객체 기반)
        Article articleToSpy = new Article("This is a very long title for an article");
        Article spyArticle = spy(articleToSpy);

        // 2. 특정 메서드의 동작을 Stubbing
        when(spyArticle.generateSummary(10)).thenReturn("Shortened...");

        // 3. 테스트 대상 서비스 객체 생성
        ArticleService articleService = new ArticleService();
        List<Article> articles = List.of(spyArticle);

        // 4. 테스트 실행
        List<String> summaries = articleService.summarizeArticles(articles, 15);

        // 5. Stubbing된 결과 검증
        assertEquals(List.of("Shortened..."), summaries);

        // 6. 다른 메서드는 여전히 실제 동작을 하는지 확인 (선택적)
        assertEquals("This is a very long title for an article", spyArticle.getTitle());
    }

    @Test
    void testGenerateSummaryWithSpyAndVerifyInteraction() {
        // 1. Spy 객체 생성 (실제 Article 객체 기반)
        Article articleToSpy = new Article("Simple Title");
        Article spyArticle = spy(articleToSpy);

        // 2. 테스트 대상 서비스 객체 생성
        ArticleService articleService = new ArticleService();
        List<Article> articles = List.of(spyArticle);

        // 3. 테스트 실행
        List<String> summaries = articleService.summarizeArticles(articles, 20);

        // 4. 메서드가 특정 인자로 호출되었는지 검증
        verify(spyArticle).generateSummary(20);

        // 5. 결과 검증 (실제 동작 기반)
        assertEquals(List.of("Simple Title"), summaries);
    }
}
```

- `spy`를 제외하고는 `mock`을 "어떻게 사용하느냐"의 차이일 뿐 구현은 크게 다르지 않아 보임
- 코드만 보고서는 어떤 대역을 의도했는지 정확히 알기 어려울 가능성 존재
- 따라서 대역에 대한 "정의"를 제대로 이해하는 것이 좋을 것 같음
