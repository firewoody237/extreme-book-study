# 12. 자동 테스트

## 인수 테스트
- 시스템이 비즈니스 요구사항을 만족해서 소유권을 넘기기 전에 수행하는 테스트 단계
- 테스트 단계 중 가장 마지막에 수행됨

## 수동 테스트의 단점
- 테스트 절차를 사람이 직접 수행하고 결과를 눈으로 확인하는 데는 많은 시간과 노력이 들어감
- 사람이 테스트 하는 과정에서 실수할 수 있음
- 매번 사람이 반복적으로 테스트를 수행해야함

## 자동 테스트의 장점
- 테스트를 매번 동일하게 수행할 수 있음
- 빠른 피드백을 받을 수 있음
- 자동 테스트를 자동화하여 특정 단계에서 자동으로 수행되도록 할 수 있음
- 테스트 코드를 통해 소스 코드의 작성 의도를 파악할 수 있음

# 12.1 Regression

## 소프트웨어 개발 분야에서의 Regression
- 시스템이 정상적으로 제공하던 기능이 어떤 배포 시점을 기준으로 제대로 동작하지 않게 되는 상황을 지칭
- 해결 : 코드 변경에 따른 부작용이 생겼는지 여부 판단하는 시스템 필요 -> 회귀 테스트

## 테스트 코드 커버리지
- 전체 소스 코드 중 테스트 코드가 작성된 소스 코드의 백분율
- 꼭 100% 테스트 코드 커버리지를 지켜야할까?
  - 아니다. 개발자가 코드 변경 이후에 느끼는 안정감만 느낄 수 있는 정도면 충분하다.

# 12.2 의도
- 코드 작성 의도는 코드만으로 파악하기 힘들 수 있음
- 코드만으로는 읽는 사람에 의해 코드 작성 의도가 왜곡될 수 있음

## 코드만으로 의도를 파악하기 힘든 경우
- 단순히 유저의 id로 유저가 존재하는지만 조회하고 반환값이 없는 메서드
```java
public void doSomething(long userId) {
    userRepository.getById(userId);
    // ~~
}
```

### 어떻게 의도를 파악할 수 있는가?
- 코드 작성자에게 가서 물어본다. (불가능한 경우도 있음)
- 테스트 코드를 작성한다.

### 테스트 코드
- 유저 존재 여부를 체크하는 의도를 가지고 있음을 알 수 있다.
```java
@Test
void doSomething_호출시_유저가_없다면_에러를_던진다() {
    // given
    long userId = 1L;
    
    // when
    // then
    
    assertThatThrownBy(() -> {
        userService.doSomething(userId);
    }).isInstanceOf(ResourceNotFoundException.class);
}
```

## TDD (Test Driven Development, 테스트 주도 개발)
- 개발자가 실제로 코드를 작성하기 전에 해당 코드의 테스트 케이스를 먼저 작성하는 개발 방법

## 테스트를 작성함으로써 얻을 수 있는 장점
- 객체에 할당된 책임과 의도를 기술할 수 있음
- 책임이 제대로 구현되었는지 확인하는 역할 -> 계약서
- 객체의 책임을 실행하려면 어떤 입력을 줘야하는지 알 수 있음 -> 문서

# 12.3 레거시 코드
- 단순히 테스트 루틴이 없는 코드

## 레거시 코드가 가진 문제점
- 이해하기 어렵고, 변경하기 어려움 -> 유지보수가 어려움

## 레거시 코드가 가진 문제점을 어떻게 해결하냐
- 테스트 코드를 작성하면 됨

## 리펙터링
- 리팩터링은 코드 변경으로 인한 입력에 따른 출력이 달라지면 안된다.
- 테스트를 통해서 입출력 쌍이 변화가 없는지 확인해야함

