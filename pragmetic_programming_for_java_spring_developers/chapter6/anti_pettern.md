# 안티패턴
유지보수가 어렵고 확장성이 떨어지는 설계 패턴

## 용어 정의
### 확장성
- 기능 확장성 (Functional Scalability)
    - 새로운 기능이나 요구사항이 생겼을 때, 기존 시스템에 큰 수정 없이 추가하거나 변경할 수 있는 유연성
- 성능 확장성 (Performance Scalability)
    - 사용자가 많아지거나 데이터가 증가했을 때, 성능 저하 없이 시스템이 잘 버틸 수 있는 능력

### 레이어
- 시스템을 논리적으로 나눈 계층 구조
- 각 레이어는 특정한 책임과 역할을 가진다.
- 다른 레이어와 명확히 구분된 의존성 구조를 가진다.

---

# 스마트 UI
- UI 레벨에서 데이터 입출력, 비즈니스 로직, 데이터베이스 통신 코드가 처리하는 설계
- 컨트롤러의 핸들러에 지나치게 많은 비즈니스 로직이 들어있는 설계

## 문제점
### 유지보수성 관점
#### 로직 추적 어려움
- 버그가 발생했을 때, UI와 비즈니스 로직이 뒤섞여 있어 디버깅이 힘듦
#### 테스트 난이도 증가
- UI와 비즈니스 로직이 얽혀 있어 유닛 테스트가 어려움
#### 변경에 민감
- 작은 로직 변경이 전체 컴포넌트 변경으로 이어질 수 있음

### 확장성 관점
#### 재사용 어려움
- 상태와 로직이 결합되어 있어 컴포넌트 재사용이 힘듦
#### 구조적 분리가 어려움
- 기능 단위로 확장하거나 교체하기 어려움
#### 변화에 유연하지 않음
- 도메인 로직 변화 시 UI 구조도 함께 수정해야 하는 경우가 많음

## 컨트롤러의 역할
사용자의 입출력을 받고 어떤 비즈니스 로직을 실행할지 결정하는 역할만 해야함

---

# 양방향 레이어드 아키텍처
레이어 간 의존 방향이 **양방향**인 설계

## 레이어드 아키텍처
### 종류
#### 프레젠테이션 레이어
- 사용자와 상호작용을 처리하고 결과를 표시하는 역할 담당
- 컨트롤러 컴포넌트
#### 비즈니스 레이어
- 애플리케이션의 비즈니스 로직을 처리하는 역할
- 서비스 컴포넌트
#### 인프라스트럭처 레이어
- 외부 시스템과의 상호작용을 담당
- 영속성 컴포넌트
### 장점
- 단순하고 직관적인 구조 -> 기능 개발이 쉬워짐
- 개발자가 컴포넌트 배치를 고민할 필요 없음
### 제약
- 레이어 간 의존 방향은 단방향을 유지해야 한다.
- 레이어 간 통신은 인접한 레이어끼리 이뤄져야 한다.

## 양방향 레이어드 아키텍처를 쓰면 안되는 이유
### 영향 범위 추가
- 하위 레이어가 상위 레이어를 참조하면, 상위 로직 변경 시 하위 레이어도 함께 변경되어야함
- 의존성이 뒤엉기고 유지보수가 어려워짐

---

## 완화된 레이어드 아키텍처
- 2개 이상의 레이어를 건너 뛰어 통신하는 구조
- 역할과 책임에 따라 레이어별로 코드가 모이지 않을 수 있으므로 안티패턴임

## 모듈에 의존하는 레이어들
- 레이어들이 하나의 공통 모듈에 의존하는 모습이 흡사 완화된 레이어드 아키텍처처럼 보임
- 하지만 모듈은 레이어가 아니므로 완화된 레이어드 아키텍처라고 볼 수 없음을 유의

---

# 트랜잭션 스크립트
비즈니스 로직을 서비스 레이어에서 처리하는 설계

## 트랜잭션 스크립트를 사용하면 안되는 이유
### 코드가 객체지향적에서 절차지향적으로 변함
- 역할과 책임에 따라 객체의 행동(비즈니스 로직)을 도메인에 정의해야한다.
- 하지만 비즈니스 로직을 서비스에 몰아서 처리해버리면 객체지향이 의미가 없어진다.
- 결국 절차지향적 코드가 만들어진다.

### 절차지향의 단점
- 변경에 취약해짐
- 확장에 취약해짐
- 업무 병령 처리가 어려움

## 비즈니스 로직은 어디에 위치해야하는가?
- 도메인 모델

## 서비스는 어떤 역할을 취해야하나?
- 도메인에 일을 위임하는 역할